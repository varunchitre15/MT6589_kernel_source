/*****************************************************************************/
/* Copyright (c) 2009 NXP Semiconductors BV                                  */
/*                                                                           */
/* This program is free software; you can redistribute it and/or modify      */
/* it under the terms of the GNU General Public License as published by      */
/* the Free Software Foundation, using version 2 of the License.             */
/*                                                                           */
/* This program is distributed in the hope that it will be useful,           */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
/* GNU General Public License for more details.                              */
/*                                                                           */
/* You should have received a copy of the GNU General Public License         */
/* along with this program; if not, write to the Free Software               */
/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
/* USA.                                                                      */
/*                                                                           */
/*****************************************************************************/
#if defined(MTK_HDMI_SUPPORT)
#define TMFL_TDA19989

#define _tx_c_
#include <linux/autoconf.h>
#include <linux/mm.h>
#include <linux/init.h>
#include <linux/fb.h>
#include <linux/delay.h>
#include <linux/device.h>
#include <linux/platform_device.h>
#include <linux/dma-mapping.h>
#include <linux/earlysuspend.h>
#include <linux/kthread.h>
#include <linux/rtpm_prio.h>
#include <linux/vmalloc.h>
#include <linux/disp_assert_layer.h>

#include <asm/uaccess.h>
#include <asm/atomic.h>
#include <asm/mach-types.h>
#include <asm/cacheflush.h>
#include <asm/io.h>

#include <mach/dma.h>
#include <mach/irqs.h>

#include <linux/miscdevice.h>
#include <linux/platform_device.h>
#include <linux/fs.h>
#include <linux/file.h>
#include <linux/mm.h>
#include <linux/cdev.h>
#include <asm/tlbflush.h>
#include <asm/page.h>
#include <asm/io.h>
#include <asm/uaccess.h>
#include <linux/slab.h>

#include <linux/autoconf.h>
#include <linux/module.h>
#include <linux/mm.h>
#include <linux/init.h>
#include <linux/fb.h>
#include <linux/delay.h>
#include <linux/device.h>
#include <linux/platform_device.h>
#include <linux/dma-mapping.h>
#include <linux/earlysuspend.h>
#include <linux/kthread.h>
#include <linux/rtpm_prio.h>

#include <asm/uaccess.h>
#include <asm/atomic.h>
#include <asm/mach-types.h>
#include <asm/cacheflush.h>
#include <asm/io.h>

#include <mach/dma.h>
#include <mach/irqs.h>
#include <linux/vmalloc.h>

#include <asm/uaccess.h>

#include "hdmi_drv.h"

#include "lcd_drv.h"
#include "lcd_reg.h"
#include "dsi_reg.h"
#include "dpi_drv.h"
#include "dpi_reg.h"
#include "mach/eint.h"
#include "mach/irqs.h"
#include "hdmitx.h"

#include <linux/switch.h>
#if defined(CONFIG_ARCH_MT6575)
	#include <mach/mt6575_m4u.h>
#else
    #error "unknown arch"
#endif

#undef OUTREG32
#define OUTREG32(x, y) {/*printk("[hdmi]write 0x%08x to 0x%08x\n", (y), (x)); */__OUTREG32((x),(y))}
#define __OUTREG32(x,y) {*(unsigned int*)(x)=(y);}



#ifdef I2C_DBG
#include "tmbslHdmiTx_types.h"
#include "tmbslTDA9989_local.h"
#endif

#if defined(CONFIG_ARCH_MT6575)
#include <mach/mt6575_typedefs.h>
#include <mach/mt6575_gpio.h>
#include <mach/mt6575_m4u.h>
#include <mach/mt_clkmgr.h>
#endif
#include <mach/mt6575_m4u.h>
#include <mach/mt6575_mdp.h>

#include <mach/mt6575_reg_base.h>
static PDSI_PHY_REGS const DSI_PHY_REG_DPI = (PDSI_PHY_REGS)(MIPI_CONFG_BASE + 0x800);
extern int m4u_config_port(M4U_PORT_STRUCT* pm4uport);
extern void HDMI_DBG_Init(void);



extern UINT32 DISP_GetScreenHeight(void);
extern UINT32 DISP_GetScreenWidth(void);

static size_t hdmi_log_on = true;
static struct switch_dev hdmi_switch_data;
#define HDMI_LOG(fmt, arg...) \
	do { \
		if (hdmi_log_on) {printk("[hdmi]%s,#%d ", __func__, __LINE__); printk(fmt, ##arg);} \
	}while (0)
        
#define HDMI_FUNC()	\
    do { \
        if(hdmi_log_on) printk("[hdmi] %s\n", __func__); \
    }while (0)
                
#define HDMI_LINE()	\
    do { \
        if (hdmi_log_on) {printk("[hdmi]%s,%d ", __func__, __LINE__); printk(fmt, ##arg);} \
    }while (0)

void hdmi_log_enable(int enable)
{
	printk("hdmi log %s\n", enable?"enabled":"disabled");
	hdmi_log_on = enable;
}

extern int pll_fsel(enum mt65xx_pll_id id, unsigned int pll_value);
#define HDMI_DEVNAME "hdmitx"
HDMI_PARAMS _s_hdmi_params = {0};
HDMI_PARAMS *hdmi_params = &_s_hdmi_params;
HDMI_DRIVER *hdmi_drv = NULL;

DEFINE_SEMAPHORE(hdmi_update_mutex);
typedef struct{
    bool is_ipo_poweroff;
    bool is_force_fullscreen;
    bool is_force_portrait; // whether forced portrait mode, priority is higher than is_force_fullscreen
	bool is_reconfig_needed;
	bool is_enabled;    // whether enabled by user
    bool is_active;     // whether active with cable pluged in.
    bool is_clock_on;
	bool is_video_avaliable;
	bool is_audio_avaliable;
	int 	lcm_width;
	int		lcm_height;
	int		hdmi_width;
	int		hdmi_height;
	int		output_width;
	int		output_height;
    int     output_buffer_offset;
	HDMI_VIDEO_RESOLUTION		output_resolution;
	int		orientation;
    int     orientation_store;
    int     orientation_store_portrait;
}_t_hdmi_context;
static _t_hdmi_context hdmi_context;
static _t_hdmi_context *phdmi_context = &hdmi_context;

#define IS_HDMI_ON	(phdmi_context->is_enabled == TRUE)
#define IS_HDMI_OFF	(phdmi_context->is_enabled == FALSE)

extern int m4u_alloc_mva_stub(M4U_MODULE_ID_ENUM eModuleID, const unsigned int BufAddr, const unsigned int BufSize, unsigned int *pRetMVABuf);
extern int m4u_dealloc_mva_stub(M4U_MODULE_ID_ENUM eModuleID, const unsigned int BufAddr, const unsigned int BufSize, const unsigned int MVA);
extern int m4u_config_port_stub(M4U_PORT_STRUCT* pM4uPort);

extern int m4u_insert_tlb_range_stub(M4U_MODULE_ID_ENUM eModuleID, unsigned int MVAStart, const unsigned int MVAEnd, M4U_RANGE_PRIORITY_ENUM ePriority, unsigned int entryCount);
extern int m4u_invalid_tlb_range_stub(M4U_MODULE_ID_ENUM eModuleID, unsigned int MVAStart, unsigned int MVAEnd);
unsigned int temp_mva, temp_va, hdmi_va, hdmi_mva, fb_pa, fb_va, fb_size;
static dev_t hdmi_devno;
static struct cdev *hdmi_cdev;
static struct class *hdmi_class = NULL;

static UINT32 const DPI_PAD_CON = 0xf2080900;
static UINT32 const NLI_ARB_CS = 0xf100d014;

static int hdmi_default_width = 1920;
static int hdmi_default_height = 1080;

static int hdmi_buffer_write_id = 0;
static int hdmi_buffer_read_id = 0;
static int hdmi_buffer_lcdw_id = 0;

DPI_POLARITY clk_pol, de_pol, hsync_pol, vsync_pol;
unsigned int dpi_clk_div, dpi_clk_duty, hsync_pulse_width, hsync_back_porch, hsync_front_porch, vsync_pulse_width, vsync_back_porch, vsync_front_porch, mipi_pll_clk_ref, mipi_pll_clk_div1, mipi_pll_clk_div2, intermediat_buffer_num;
HDMI_COLOR_ORDER rgb_order;


static struct task_struct *hdmi_update_task = NULL;

wait_queue_head_t hdmi_update_wq;
atomic_t hdmi_update_event = ATOMIC_INIT(0);

unsigned int hdmi_resolution_param_table[][3] = 
{
        {720,   480,    60},
        {1280,  720,    60},
        {1920,  1080,   60},
};


static void hdmi_udelay(unsigned int us)
{
	udelay(us);
}

static void hdmi_mdelay(unsigned int ms)
{
	msleep(ms);
}

static unsigned int hdmi_get_width(HDMI_VIDEO_RESOLUTION r)
{
    ASSERT(r < HDMI_VIDEO_RESOLUTION_NUM);
    return hdmi_resolution_param_table[r][0];
}

static unsigned int hdmi_get_height(HDMI_VIDEO_RESOLUTION r)
{
    ASSERT(r < HDMI_VIDEO_RESOLUTION_NUM);
    return hdmi_resolution_param_table[r][1];
}


void hdmi_cable_fake_plug_in(void)
{
	switch_set_state(&hdmi_switch_data, HDMI_STATE_ACTIVE); 
}

void hdmi_cable_fake_plug_out(void)
{
	switch_set_state(&hdmi_switch_data, HDMI_STATE_ACTIVE); 
}

extern const HDMI_DRIVER* HDMI_GetDriver();


static void freq_meter(void)
{
	unsigned int temp = 0;
	unsigned int temp1 = 0;
	__OUTREG32(0xF0007400, 0xC800);
	__OUTREG32(0xF0007404, 0x000B);
	__OUTREG32(0xF0007400, 0x8800);
	while(INREG32(0xF0007404) & 0x8000);
	temp = INREG32(0xF0007410);
	//printk("tvdss clock=%d, %dMhz\n", temp, (temp+1)*26/2048);

	__OUTREG32(0xF0007400, 0xC800);
	__OUTREG32(0xF0007404, 0x0008);
	__OUTREG32(0xF0007400, 0x8800);
	while(INREG32(0xF0007404) & 0x8000);
	temp1 = INREG32(0xF0007410);
	//printk("upll clock=%d, %dMhz\n", temp, (temp+1)*26/2048);
	printk("[hdmi]upll=%dMhz, tvdss=%dMhz\n", (temp1+1)*26/2048, (temp+1)*26/2048);
}

static long int get_current_time_us(void)
{
	struct timeval t;
	do_gettimeofday(&t);
	return (t.tv_sec & 0xFFF) * 1000000 + t.tv_usec;
}




extern unsigned int DPI_GetCurrentFB(void);
bool is_hdmi_active()
{
	return phdmi_context->is_active;
}

bool is_hdmi_clock_on()
{
	return phdmi_context->is_clock_on;
}


void hdmi_power_on(void)
{
    HDMI_FUNC();    
    
    hdmi_drv->power_on();

    return;
}
void hdmi_power_off(void)
{
    HDMI_FUNC();    
    
	hdmi_drv->power_off();

    return;
}

static int hdmi_update_kthread(void *data)
{
	struct sched_param param = { .sched_priority = RTPM_PRIO_SCRN_UPDATE };
	sched_setscheduler(current, SCHED_RR, &param);
    
    for( ;; ) {
        wait_event_interruptible(hdmi_update_wq, atomic_read(&hdmi_update_event));
		//HDMI_LOG("wq wakeup\n");
        //hdmi_update_impl();

		atomic_set(&hdmi_update_event,0);
        hdmi_update_impl();
        if (kthread_should_stop())
            break;
    }

    return 0;
}

void hdmi_source_buffer_switch(void)
{
    //printk("lcd write buffer:%d\n", hdmi_buffer_lcdw_id);
    if(phdmi_context->is_active == false)
        return;

    //printk("lcd write buffer:%d\n", hdmi_buffer_lcdw_id);

    hdmi_buffer_lcdw_id = (hdmi_buffer_lcdw_id+1)%hdmi_params->intermediat_buffer_num;

    LCD_CHECK_RET(LCD_FBSetAddress(LCD_FB_0, temp_mva + phdmi_context->lcm_width*phdmi_context->lcm_height*3*hdmi_buffer_lcdw_id));

}

void hdmi_update_buffer_switch(void)
{
    //HDMI_LOG("DPI read buffer:%d\n", hdmi_buffer_read_id);
    if(phdmi_context->is_active == false)
        return;
    
    DPI_CHECK_RET(DPI_FBSetAddress(DPI_FB_0, hdmi_mva + phdmi_context->hdmi_width*phdmi_context->hdmi_height*3*hdmi_buffer_read_id));
}

extern void DBG_OnTriggerHDMI(void);
extern void DBG_OnHDMIDone(void);

void hdmi_update(void)
{
    //HDMI_FUNC();
#if 1
    if(phdmi_context->is_active == false)
        return;
    atomic_set(&hdmi_update_event, 1);
    wake_up_interruptible(&hdmi_update_wq);
#else
    hdmi_update_impl();
#endif
}
void hdmi_update_impl(void)
{
    int i = 0;
    int ret = 0;
    int nextfb = 0;
    MdpkBitbltConfig p;

    if(phdmi_context->is_active == false || phdmi_context->is_ipo_poweroff == true)
    {
        HDMI_LOG("ignored[hdmi disabled]\n");
        return;
    }

    if(phdmi_context->hdmi_width * phdmi_context->hdmi_height == 0)
    {
        HDMI_LOG("ignored[resolution is null]\n");
        return;
    }

    //HDMI_FUNC();
    if(down_interruptible(&hdmi_update_mutex))
    {
        HDMI_LOG("[HDMI] can't get semaphore in\n");
        return;
    }

    DBG_OnTriggerHDMI();
    //LCD_WaitForNotBusy();
    hdmi_buffer_write_id = (hdmi_buffer_write_id+1)%hdmi_params->intermediat_buffer_num;

    if(phdmi_context->is_reconfig_needed)
    {
        memset(hdmi_va, 0, phdmi_context->hdmi_width*phdmi_context->hdmi_height*3*hdmi_params->intermediat_buffer_num);
        phdmi_context->is_reconfig_needed = false;
    }
    
    memset((void*)&p, 0, sizeof(MdpkBitbltConfig));
    p.srcX = p.srcY = 0;
    p.srcW = phdmi_context->lcm_width;
    p.srcH	= phdmi_context->lcm_height;
    p.srcWStride = phdmi_context->lcm_width;
    p.srcHStride = phdmi_context->lcm_height;
            p.srcAddr = temp_va + phdmi_context->lcm_width*phdmi_context->lcm_height*3*((hdmi_buffer_lcdw_id+2)%hdmi_params->intermediat_buffer_num);
    p.srcFormat = MDPK_FORMAT_RGB_888;
    p.srcBufferSize = phdmi_context->lcm_width*phdmi_context->lcm_height*3;
    p.srcMemType =  MDPK_MEMTYPE_VMALLOC;

    p.orientation = phdmi_context->orientation;
    switch(p.orientation)
    {
        case 0:
        case 2:
        {
            p.dstW = phdmi_context->lcm_width*phdmi_context->hdmi_height/phdmi_context->lcm_height;
            p.dstH = phdmi_context->hdmi_height;
            p.dstAddr = hdmi_va + hdmi_buffer_write_id*phdmi_context->hdmi_width*phdmi_context->hdmi_height*3+(phdmi_context->hdmi_width - p.dstW)/2*3;
            p.dstFormat = MDPK_FORMAT_RGB_888;
            p.pitch = phdmi_context->hdmi_width;
            p.dstBufferSize = phdmi_context->hdmi_width*phdmi_context->hdmi_height*3;
            p.dstMemType =  MDPK_MEMTYPE_VMALLOC;
            break;
        }
        case 1:
        case 3:
        {
            p.dstW = phdmi_context->output_width;
            p.dstH = phdmi_context->output_height;
            p.dstAddr = hdmi_va + phdmi_context->output_buffer_offset*3+hdmi_buffer_write_id*phdmi_context->hdmi_width*phdmi_context->hdmi_height*3;
            p.dstFormat = MDPK_FORMAT_RGB_888;
            p.pitch = phdmi_context->hdmi_width;
            p.dstBufferSize = phdmi_context->hdmi_width*phdmi_context->hdmi_height*3;
            p.dstMemType =  MDPK_MEMTYPE_VMALLOC;
            break;
        }
    }
    
    //HDMI_LOG("dstw=%d, dsth=%d, ori=%d\n", p.dstW, p.dstH, p.orientation);

    MDPK_Bitblt_Config(MDPK_BB_CH_HDMI_0, &p);
            
    long int t = get_current_time_us();
    ret = MDPK_Bitblt(0);
    if(ret)
    {
        HDMI_LOG("MDPK_Bitblt fail!\n");
    }

    DBG_OnHDMIDone();
    //HDMI_LOG("cost %d us\n", get_current_time_us() - t);

    hdmi_buffer_read_id = hdmi_buffer_write_id;

    done:
    up(&hdmi_update_mutex);

    return;
}


HDMI_STATUS hdmi_drv_init(void)
{
	int ret = 0;
	int i = 0;
	HDMI_STATUS r = HDMI_STATUS_OK;
	int hdmi_width, hdmi_height;
	int lcm_width, lcm_height;

    HDMI_FUNC();

	hdmi_width = hdmi_get_width(hdmi_params->init_config.vformat);
	hdmi_height = hdmi_get_height(hdmi_params->init_config.vformat);
	
	lcm_width = DISP_GetScreenWidth();
	lcm_height = DISP_GetScreenHeight();

	printk("[hdmi]%s, hdmi_width=%d, hdmi_height=%d\n", __func__, hdmi_width, hdmi_height);
	printk("[hdmi]%s, lcm_width=%d, lcm_height=%d\n", __func__, lcm_width, lcm_height);

	M4U_PORT_STRUCT m4uport;

	memset((void*)&m4uport, 0, sizeof(M4U_PORT_STRUCT));
	m4uport.ePortID = M4U_PORT_DPI;
	m4uport.Virtuality = 1; 					   
	m4uport.Security = 0;
	m4uport.Distance = 1;
	m4uport.Direction = 0;

	if(m4u_config_port_stub(&m4uport))
	{
		printk("[hdmi]config dpi port failed\n");
		return -1;
	}

	memset((void*)&m4uport, 0, sizeof(M4U_PORT_STRUCT));
	m4uport.ePortID = M4U_PORT_LCD_W;
	m4uport.Virtuality = 1; 					   
	m4uport.Security = 0;
	m4uport.Distance = 1;
	m4uport.Direction = 0;

	if(m4u_config_port_stub(&m4uport))
	{
		printk("[hdmi]config dpi port failed\n");
		return -1;
	}
    
	temp_va = vmalloc(lcm_width*lcm_height*3*hdmi_params->intermediat_buffer_num);
	if(temp_va == NULL)
	{
		HDMI_LOG("vmalloc fail\n");
		return -1;
	}

	ret = m4u_alloc_mva_stub(M4U_CLNTMOD_LCDC, temp_va, lcm_width*lcm_height*3*hdmi_params->intermediat_buffer_num, &temp_mva);
	if(ret)
	{
		printk("[hdmi]allocate mva for dpi fail\n");
		return -1;
	}

	printk("[hdmi]%s, temp_va=0x%08x, temp_mva=0x%08x\n", __func__, temp_va, temp_mva);

	m4u_insert_tlb_range_stub(M4U_CLNTMOD_LCDC, temp_mva,temp_mva+lcm_width*lcm_height*3*hdmi_params->intermediat_buffer_num, RT_RANGE_HIGH_PRIORITY, 0);

    LCD_CHECK_RET(LCD_FBSetFormat(LCD_FB_FORMAT_RGB888));
	LCD_CHECK_RET(LCD_FBSetPitch(lcm_width*3));
	LCD_CHECK_RET(LCD_FBSetStartCoord(0, 0));

	LCD_CHECK_RET(LCD_FBSetAddress(LCD_FB_0, temp_mva));
	LCD_CHECK_RET(LCD_FBEnable(LCD_FB_0, TRUE));

	hdmi_va = vmalloc(hdmi_default_width*hdmi_default_height*3*hdmi_params->intermediat_buffer_num);
	if(hdmi_va == NULL)
	{
		printk("[hdmi]kmalloc 0x%08x fail!!!\n", hdmi_default_width*hdmi_default_height*3*hdmi_params->intermediat_buffer_num);
		return;
	}
    
	memset((void*)hdmi_va, 0, hdmi_default_width*hdmi_default_height*3*hdmi_params->intermediat_buffer_num);

	ret = m4u_alloc_mva_stub(M4U_CLNTMOD_DPI, hdmi_va, hdmi_default_width*hdmi_default_height*3*hdmi_params->intermediat_buffer_num, &hdmi_mva);
	if(ret)
	{
		printk("[hdmi]allocate mva for dpi fail\n");
		return;
	}

	m4u_insert_tlb_range_stub(M4U_CLNTMOD_DPI, hdmi_mva, hdmi_mva+hdmi_default_width*hdmi_default_height*3*hdmi_params->intermediat_buffer_num, RT_RANGE_HIGH_PRIORITY, 0);
	printk("[hdmi]%s, hdmi_va=0x%08x, hdmi_mva=0x%08x\n", __func__, hdmi_va, hdmi_mva);

	MdpkBitbltConfig p;
	memset((void*)&p, 0, sizeof(MdpkBitbltConfig));
	p.srcX = p.srcY = 0;
	p.srcW = lcm_width;
	p.srcH	= lcm_height;
	p.srcWStride = lcm_width;
	p.srcHStride = lcm_height;
	p.srcAddr = temp_va;
	p.srcFormat = MDPK_FORMAT_RGB_888;
	p.srcBufferSize = lcm_width*lcm_height*3;
	p.srcMemType =  MDPK_MEMTYPE_VMALLOC;
	p.dstW = hdmi_width;
	p.dstH = hdmi_height;
	p.dstAddr = hdmi_va;
	p.dstFormat = MDPK_FORMAT_RGB_888;
	p.pitch = hdmi_width;
	p.dstBufferSize = hdmi_width*hdmi_height*3;
	p.orientation = 3;
	p.dstMemType =  MDPK_MEMTYPE_VMALLOC;

	MDPK_Bitblt_Config(MDPK_BB_CH_HDMI_0, &p);

	phdmi_context->lcm_width = lcm_width;
	phdmi_context->lcm_height = lcm_height;
    phdmi_context->output_resolution = hdmi_params->init_config.vformat;
    
    hdmi_dpi_config_clock();
    hdmi_dpi_power_switch(false);

    LCD_WaitForNotBusy();
    LCD_SetOutputMode(3);

	return HDMI_STATUS_OK;
}

HDMI_STATUS hdmi_drv_deinit(void)
{
	int ret = 0;
	int i = 0;
	HDMI_STATUS r = HDMI_STATUS_OK;

    LCD_WaitForNotBusy();
    LCD_SetOutputMode(LCD_OUTPUT_TO_LCM);
    hdmi_dpi_power_switch(false);

    printk("[hdmi]%s, temp_va=0x%08x, temp_mva=0x%08x\n", __func__, temp_va, temp_mva);
    printk("[hdmi]%s, hdmi_va=0x%08x, hdmi_mva=0x%08x\n", __func__, hdmi_va, hdmi_mva);

	m4u_invalid_tlb_range_stub(M4U_CLNTMOD_LCDC, temp_mva,temp_mva+phdmi_context->lcm_width*phdmi_context->lcm_height*3*2);
	ret = m4u_dealloc_mva_stub(M4U_CLNTMOD_LCDC, temp_va, phdmi_context->lcm_width*phdmi_context->lcm_height*3*2, temp_mva);
	if(ret)
	{
		printk("[hdmi]allocate mva for dpi fail\n");
		return -1;
	}
    
    vfree(temp_va);
    temp_va = 0;
    printk("[hdmi]%s, temp_va=0x%08x, temp_mva=0x%08x\n", __func__, temp_va, temp_mva);
                   printk("[hdmi]%s, hdmi_va=0x%08x, hdmi_mva=0x%08x\n", __func__, hdmi_va, hdmi_mva);

    m4u_invalid_tlb_range_stub(M4U_CLNTMOD_DPI, hdmi_mva, hdmi_mva+phdmi_context->hdmi_width*phdmi_context->hdmi_height*3*2);


	ret = m4u_dealloc_mva_stub(M4U_CLNTMOD_DPI, hdmi_va, phdmi_context->hdmi_width*phdmi_context->hdmi_height*3*2, hdmi_mva);
	if(ret)
	{
		printk("[hdmi]allocate mva for dpi fail\n");
		return;
	}
    
    vfree(hdmi_va);
    hdmi_va = 0;

	return HDMI_STATUS_OK;
}

void hdmi_dpi_config_clock(void)
{
    int ret = 0;

    ret = enable_pll(MT65XX_TVDDS, "HDMI");
    if(ret)
    {
        HDMI_LOG("enable_pll fail!!\n");
    }

    switch(hdmi_params->init_config.vformat)
    {
        case HDMI_VIDEO_720x480p_60Hz:
        {
            printk("[hdmi]480p\n");
            ret = pll_fsel(MT65XX_TVDDS, 0x1C7204C7);
            ASSERT(!ret);

            dpi_clk_div = 2;
            dpi_clk_duty = 1;

            OUTREG32(0xF2080920, 1);
            OUTREG32(0xF2080900, 1);
            break;
        }
        case HDMI_VIDEO_1280x720p_60Hz:
        {
            printk("[hdmi]720p\n");
            ret = pll_fsel(MT65XX_TVDDS, 0xDBCD0119);
            ASSERT(!ret);

            dpi_clk_div = 2;
            dpi_clk_duty = 1;

            OUTREG32(0xF2080920, 1);
            OUTREG32(0xF2080900, 1);
            break;
        }
    }

    clk_pol     = hdmi_params->clk_pol;
    de_pol      = hdmi_params->de_pol;
    hsync_pol   = hdmi_params->hsync_pol;
    vsync_pol   = hdmi_params->vsync_pol;;

    hsync_pulse_width   = hdmi_params->hsync_pulse_width;
    vsync_pulse_width   = hdmi_params->vsync_pulse_width;
    hsync_back_porch    = hdmi_params->hsync_back_porch;
    vsync_back_porch    = hdmi_params->vsync_back_porch;
    hsync_front_porch   = hdmi_params->hsync_front_porch;
    vsync_front_porch   = hdmi_params->vsync_front_porch;

    rgb_order           = hdmi_params->rgb_order;
    intermediat_buffer_num = hdmi_params->intermediat_buffer_num;

    // dpi clock configuration using MIPITX

    DPI_CHECK_RET(DPI_Init(FALSE));

    DPI_CHECK_RET(DPI_ConfigPixelClk(clk_pol, dpi_clk_div, dpi_clk_duty));

    DPI_CHECK_RET(DPI_ConfigDataEnable(de_pol));

    DPI_CHECK_RET(DPI_ConfigHsync(hsync_pol, hsync_pulse_width, hsync_back_porch, hsync_front_porch));

    DPI_CHECK_RET(DPI_ConfigVsync(vsync_pol, vsync_pulse_width, vsync_back_porch, vsync_front_porch));

    DPI_CHECK_RET(DPI_FBSetSize(phdmi_context->hdmi_width, phdmi_context->hdmi_height));

    {
        DPI_CHECK_RET(DPI_FBSetAddress(DPI_FB_0, hdmi_mva));
        DPI_CHECK_RET(DPI_FBSetPitch(DPI_FB_0, phdmi_context->hdmi_width*3));
        DPI_CHECK_RET(DPI_FBEnable(DPI_FB_0, TRUE));
    }

    OUTREG32(0xF208C090, 0x41);
    DPI_CHECK_RET(DPI_FBSetFormat(DPI_FB_FORMAT_RGB888));

    if (LCM_COLOR_ORDER_BGR == rgb_order) 
    {
        DPI_CHECK_RET(DPI_SetRGBOrder(DPI_RGB_ORDER_RGB, DPI_RGB_ORDER_BGR));
    }
    else 
    {
        DPI_CHECK_RET(DPI_SetRGBOrder(DPI_RGB_ORDER_RGB, DPI_RGB_ORDER_RGB));
    }

    DPI_CHECK_RET(DPI_EnableClk());

    phdmi_context->is_clock_on = true;
}

void hdmi_dpi_power_switch(bool enable)
{
    int ret;

    HDMI_LOG("DPI clock:%d\n", enable);
    
    if(enable)
    {
        if(phdmi_context->is_clock_on == true)
        {
            HDMI_LOG("power on request while already powered on!\n");
            return;
        }
        
        ret = enable_pll(MT65XX_TVDDS, "HDMI");
        if(ret)
        {
            HDMI_LOG("enable_pll fail!!\n");
            return;
        }
        
        DPI_PowerOn();
        OUTREG32(0xF2080920, 1);
        OUTREG32(0xF2080900, 1);
        DPI_CHECK_RET(DPI_EnableClk());
        phdmi_context->is_clock_on = true;
    }
    else
    {
        if(phdmi_context->is_clock_on == false)
        {
            HDMI_LOG("power off request while already powered off!\n");
            return;
        }
        
        DPI_DisableClk();
        DPI_PowerOff();
        ret = disable_pll(MT65XX_TVDDS, "HDMI");
        if(ret)
        {
            HDMI_LOG("disable_pll fail!!\n");
            return;
        }
        
        phdmi_context->is_clock_on = false;
    }
}

int hdmi_video_config(HDMI_VIDEO_RESOLUTION vformat, HDMI_VIDEO_INPUT_FORMAT vin, HDMI_VIDEO_OUTPUT_FORMAT vout)
{
    if(phdmi_context->is_active == false || phdmi_context->is_ipo_poweroff == true)
    {
        HDMI_LOG("ignored\n");
        return;
    }
    
	return hdmi_drv->video_config(vformat, vin, vout);
}

int hdmi_audio_config(int samplerate)
{
    HDMI_FUNC();
    if(phdmi_context->is_active == false || phdmi_context->is_ipo_poweroff == true)
    {
        HDMI_LOG("ignored\n");
        return;
    }
    
    HDMI_LOG("sample rate=%d\n", samplerate);
    if(samplerate == 48000)
	    hdmi_drv->audio_config(HDMI_AUDIO_PCM_16bit_48000);
    else if(samplerate == 44100)
	    hdmi_drv->audio_config(HDMI_AUDIO_PCM_16bit_44100);
    else if(samplerate == 32000)
	    hdmi_drv->audio_config(HDMI_AUDIO_PCM_16bit_32000);
    else
        HDMI_LOG("samplerate not support:%d\n", samplerate);

    return 0;
}

int hdmi_video_enable(bool enable)
{
    HDMI_FUNC();
    if(phdmi_context->is_active == false || phdmi_context->is_ipo_poweroff == true)
    {
        HDMI_LOG("ignored\n");
        return;
    }

	return hdmi_drv->video_enable(enable);
}

int hdmi_audio_enable(bool enable)
{
    HDMI_FUNC();
    if(phdmi_context->is_active == false || phdmi_context->is_ipo_poweroff == true)
    {
        HDMI_LOG("ignored\n");
        return;
    }

	return hdmi_drv->audio_enable(enable);
}

struct timer_list timer;
void __timer_isr(unsigned long n)
{
    HDMI_FUNC();
    if(hdmi_drv->audio_enable) hdmi_drv->audio_enable(true);

    del_timer(&timer);
}

int hdmi_audio_delay_mute(int latency)
{
    HDMI_FUNC();
    memset((void*)&timer, 0, sizeof(timer));
    timer.expires = jiffies +  ( latency * HZ / 1000 );
    timer.function = __timer_isr;
    init_timer(&timer);
    add_timer(&timer);
    if(hdmi_drv->audio_enable) hdmi_drv->audio_enable(false);
}

static void hdmi_state_reset(void)
{
    HDMI_FUNC();

    if(hdmi_drv->get_state() == HDMI_STATE_ACTIVE)
    {
        phdmi_context->is_active = true;

        switch_set_state(&hdmi_switch_data, HDMI_STATE_ACTIVE); 
    }
    else
    {
        phdmi_context->is_active = false;
        switch_set_state(&hdmi_switch_data, HDMI_STATE_NO_DEVICE); 
    }
}

static void hdmi_state_callback(HDMI_STATE state)
{
	int ret, i;
        
    static int is_first_time = 1;
    printk("[hdmi]%s, state = %d\n", __func__, state);

   if(phdmi_context->is_ipo_poweroff == true)
   {
        HDMI_LOG("ingored\n");
        return;
   }

	switch(state)
	{
        case HDMI_STATE_NO_DEVICE: 
        {
            if(phdmi_context->is_active == false)
            {
                HDMI_LOG("request ignored, is_active=%d\n", phdmi_context->is_active);
                break;
            }
            hdmi_suspend();
            phdmi_context->is_active = false;


            switch_set_state(&hdmi_switch_data, HDMI_STATE_NO_DEVICE); 
             
            break;
        }
        case HDMI_STATE_ACTIVE:	
        {
            if(phdmi_context->is_active == true)
            {
                HDMI_LOG("request ignored, is_active=%d\n", phdmi_context->is_active);
                break;
            }

            phdmi_context->is_active = true;
            hdmi_resume();

            msleep(1000);
            switch_set_state(&hdmi_switch_data, HDMI_STATE_ACTIVE); 

            break;
        }
        default:
        {
            printk("[hdmi]%s, state not support\n", __func__); 
            return;
        } 
	}

}

void hdmi_suspend(void)
{
    HDMI_FUNC();    
    if(phdmi_context->is_active == false || phdmi_context->is_ipo_poweroff == true)
    {
        HDMI_LOG("ignored\n");
        return;
    }
    
    if (down_interruptible(&hdmi_update_mutex)) {
        printk("[hdmi][HDMI] can't get semaphore in %s()\n", __func__);
        return;
    }

    hdmi_dpi_power_switch(false);

    //hdmi_drv->suspend();
    up(&hdmi_update_mutex);
}

void hdmi_resume(void)
{
    HDMI_FUNC();    

    if(phdmi_context->is_active == false || phdmi_context->is_ipo_poweroff == true)
    {
        HDMI_LOG("ignored\n");
        return;
    }
    
    if (down_interruptible(&hdmi_update_mutex)) {
        printk("[hdmi][HDMI] can't get semaphore in %s()\n", __func__);
        return;
    }

    hdmi_dpi_power_switch(true);
    hdmi_video_config(phdmi_context->output_resolution, HDMI_VIN_FORMAT_RGB888, HDMI_VOUT_FORMAT_RGB888);

    //hdmi_drv->resume();

    up(&hdmi_update_mutex);
}

void hdmi_setorientation(int orientation)
{
	printk("[hdmi]%s, orientation=%d\n", __func__, orientation);

	if(down_interruptible(&hdmi_update_mutex))
	{
		printk("[hdmi][HDMI] can't get semaphore in %s\n", __func__);
		return;
	}

    if (phdmi_context->is_force_fullscreen == true || phdmi_context->is_force_portrait == true)
    {
        if (phdmi_context->is_force_fullscreen == true)
        {
    	    phdmi_context->orientation_store = orientation;
        }
        else
        {
            phdmi_context->orientation_store_portrait = orientation;
        }
        //HDMI_LOG("Force fullscreen is enabled, ignore phone rotation\n");
        HDMI_LOG("Force fullscreen or portrait is enabled, ignore phone rotation, orientation_store = %d\n", orientation);
        goto done;
    }
    
	phdmi_context->orientation = orientation;
	phdmi_context->is_reconfig_needed = true;

done:
	up(&hdmi_update_mutex);
}

static int hdmi_release(struct inode *inode, struct file *file)
{
    printk("[hdmi]%s\n", __func__);
	return 0;
}

static int hdmi_open(struct inode *inode, struct file *file)
{ 
    printk("[hdmi]%s\n", __func__);
	return 0;
}

static long hdmi_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	void __user *argp = (void __user *)arg;

	int r = 0;

	HDMI_LOG("cmd=0x%08x, arg=0x%08x\n", cmd, arg);

    switch(cmd)
    {
        case MTK_HDMI_FORCE_FULLSCREEN_ON:
        {
            if(down_interruptible(&hdmi_update_mutex))
            {
                HDMI_LOG("[HDMI] can't get semaphore in\n");
                return;
            }

            phdmi_context->is_force_fullscreen = true;
            if (phdmi_context->is_force_portrait)
            {
                phdmi_context->orientation_store_portrait = 3;
                HDMI_LOG("[HDMIPortrait] hdmi force camera on when portrait on\n");
            }
            else
            {
                if (3 != phdmi_context->orientation)
                {
        	        phdmi_context->orientation = 3;
        	        phdmi_context->is_reconfig_needed = true;
                }
                HDMI_LOG("[HDMIPortrait] hdmi force camera on when portrait off\n");
            }
            up(&hdmi_update_mutex);
            break;
        }
        case MTK_HDMI_FORCE_FULLSCREEN_OFF:
        {
            if(down_interruptible(&hdmi_update_mutex))
            {
                HDMI_LOG("[HDMI] can't get semaphore in\n");
                return;
            }

            phdmi_context->is_force_fullscreen = false;
            if (phdmi_context->is_force_portrait)
            {
                phdmi_context->orientation_store_portrait = phdmi_context->orientation_store;
                HDMI_LOG("[HDMIPortrait] hdmi force camera off when portrait on, orientation_store_portrait = %d\n", phdmi_context->orientation_store_portrait);
            }
            else
            {
        	phdmi_context->orientation = phdmi_context->orientation_store;
        	phdmi_context->is_reconfig_needed = true;
                HDMI_LOG("[HDMIPortrait] hdmi force camera off when portrait off\n");
            }
            up(&hdmi_update_mutex);
            break;
        }
        case MTK_HDMI_PORTRAIT_ENABLE:
        {
            if(down_interruptible(&hdmi_update_mutex))
            {
                HDMI_LOG("[HDMI] can't get semaphore in\n");
                return;
            }

            if (arg)
            {
                HDMI_LOG("[HDMIPortrait] hdmi force portrait on\n");
                phdmi_context->is_force_portrait = true;
                phdmi_context->orientation_store_portrait = phdmi_context->orientation; //backup original orientation
                phdmi_context->orientation = 0;
                phdmi_context->is_reconfig_needed = true;
            }
            else
            {
                HDMI_LOG("[HDMIPortrait] hdmi force portrait off\n");
                phdmi_context->is_force_portrait = false;
                phdmi_context->orientation = phdmi_context->orientation_store_portrait; //restore original orientation
                phdmi_context->is_reconfig_needed = true;
            }
            up(&hdmi_update_mutex);
            break;
        }
        case MTK_HDMI_IPO_POWERON:
        {
            if (arg) 
            {
                phdmi_context->is_ipo_poweroff = false;
                hdmi_resume();
                hdmi_state_reset();
            }
            else
            {
                hdmi_suspend();
                phdmi_context->is_ipo_poweroff = true;
                memset((void*)hdmi_va, 0, hdmi_default_width*hdmi_default_height*3*hdmi_params->intermediat_buffer_num);

            }
            break;
        }
        case MTK_HDMI_POWER_ENABLE:
        {
            if (arg)
            {
                hdmi_resume();
            }
            else
            {
                hdmi_suspend();
                memset((void*)hdmi_va, 0, hdmi_default_width*hdmi_default_height*3*hdmi_params->intermediat_buffer_num);
            }
            break;
        }
        case MTK_HDMI_AUDIO_VIDEO_ENABLE:
        {
            if(phdmi_context->is_ipo_poweroff == true)
            {
                HDMI_LOG("ignored\n");
                return;
            }
            
            if (arg) 
            {
                if(phdmi_context->is_enabled)
                    return 0;
                
                hdmi_drv->init();
                HDMI_CHECK_RET(hdmi_drv_init());
                hdmi_power_on();
                hdmi_video_config(HDMI_VIDEO_1280x720p_60Hz, HDMI_VIN_FORMAT_RGB888, HDMI_VOUT_FORMAT_RGB888);
                hdmi_audio_config(44100);
                phdmi_context->is_enabled = true;
            } 
            else 
            {
                if(!phdmi_context->is_enabled)
                    return 0;

                hdmi_power_off();
                HDMI_CHECK_RET(hdmi_drv_deinit());
                hdmi_drv->exit();
                phdmi_context->is_enabled = false;
            }

            break;
        }
        case MTK_HDMI_AUDIO_ENABLE:
        {
            if(phdmi_context->is_active == false)
            {
                HDMI_LOG("ignore this ioctl because hdmitx is not active\n");
                break;
            }
            
            if (arg) 
            {
                HDMI_CHECK_RET(hdmi_audio_enable(true));
            } 
            else 
            {
                HDMI_CHECK_RET(hdmi_audio_enable(false));
            }
            
            break;
        }
        case MTK_HDMI_VIDEO_ENABLE:
        {
            if(phdmi_context->is_active == false)
            {
                HDMI_LOG("ignore this ioctl because hdmitx is not active\n");
                break;
            }
            break;
            #if 0
            if (arg) 
            {
                HDMI_CHECK_RET(hdmi_video_enable(true));
            } 
            else 
            {
                HDMI_CHECK_RET(hdmi_video_enable(false));
            }
            
            break;
            #endif
        }
        case MTK_HDMI_VIDEO_CONFIG:
        {
            HDMI_VIDEO_RESOLUTION reso;
            HDMI_LOG("video resolution configuration, arg=%d\n", arg);
            if(phdmi_context->is_active == false)
            {
                HDMI_LOG("ignore this ioctl because hdmitx is not active\n");
                break;
            }

            if(hdmi_default_width * hdmi_default_height < hdmi_get_width(reso) * hdmi_get_height(reso))
            {
                break;
            }
            
            if(down_interruptible(&hdmi_update_mutex))
            {
                HDMI_LOG("[HDMI] can't get semaphore in\n");
                return;
            }
            
            if(arg == 3 || arg == 1) // auto or 720p
            {
                HDMI_LOG("video reso: auto\n");
                if(phdmi_context->hdmi_width == 1280)
                {
                    HDMI_LOG("reso is the same\n");
                    up(&hdmi_update_mutex);
                    break;
                }


                dpi_clk_div = 2;

                hsync_front_porch   = 75;
                hsync_pulse_width   = 40;
                hsync_back_porch    = 255;    
                vsync_front_porch   = 1;
                vsync_pulse_width   = 5;
                vsync_back_porch    = 24;
                phdmi_context->hdmi_width = 1280;
                phdmi_context->hdmi_height = 720;
                phdmi_context->output_width = 1265;
                phdmi_context->output_height = 712;
                phdmi_context->output_buffer_offset = 1280*4+10;
                phdmi_context->output_resolution = HDMI_VIDEO_1280x720p_60Hz;
            }
            else if(arg == 2) //1080p
            {
                HDMI_LOG("video reso: 1080p\n");
                if(phdmi_context->hdmi_width == 1920)
                {
                    HDMI_LOG("reso is the same\n");
                    up(&hdmi_update_mutex);
                    break;
                }


                dpi_clk_div = 2;
            
                hsync_front_porch   = 44;
                hsync_pulse_width   = 44;
                hsync_back_porch    = 192;    
                vsync_front_porch   = 4;
                vsync_pulse_width   = 5;
                vsync_back_porch    = 36;
                phdmi_context->hdmi_width = 1920;
                phdmi_context->hdmi_height = 1080;
                phdmi_context->output_width = 1920;
                phdmi_context->output_height = 1080;
                phdmi_context->output_buffer_offset = 0;
                phdmi_context->output_resolution = HDMI_VIDEO_1920x1080p_30Hz;
            }
            else if(arg == 0) // 480p
            {
                HDMI_LOG("video reso: 480p\n");
                if(phdmi_context->hdmi_width == 720)
                {
                    HDMI_LOG("reso is the same\n");
                    up(&hdmi_update_mutex);
                    break;
                }
                //pll_fsel(MT65XX_TVDDS, 0x1C7204C7);

                dpi_clk_div = 4;
            
                hsync_front_porch   = 16;
                hsync_pulse_width   = 62;
                hsync_back_porch    = 60;    
                vsync_front_porch   = 9;
                vsync_pulse_width   = 6;
                vsync_back_porch    = 30;
                phdmi_context->hdmi_width = 720;
                phdmi_context->hdmi_height = 480;
                phdmi_context->output_width = 720;
                phdmi_context->output_height = 480;
                phdmi_context->output_buffer_offset = 0;
                phdmi_context->output_resolution = HDMI_VIDEO_720x480p_60Hz;
            }
            
            memset((void*)hdmi_va, 0, hdmi_default_width*hdmi_default_height*3*hdmi_params->intermediat_buffer_num);

            hdmi_video_config(phdmi_context->output_resolution, HDMI_VIN_FORMAT_RGB888, HDMI_VOUT_FORMAT_RGB888);

            DPI_CHECK_RET(DPI_DisableClk());
            DPI_CHECK_RET(DPI_ConfigPixelClk(clk_pol, dpi_clk_div, dpi_clk_duty));

            DPI_CHECK_RET(DPI_ConfigHsync(hsync_pol, hsync_pulse_width, hsync_back_porch, hsync_front_porch));

            DPI_CHECK_RET(DPI_ConfigVsync(vsync_pol, vsync_pulse_width, vsync_back_porch, vsync_front_porch));

            DPI_CHECK_RET(DPI_FBSetSize(phdmi_context->hdmi_width, phdmi_context->hdmi_height));

            DPI_CHECK_RET(DPI_FBSetPitch(DPI_FB_0, phdmi_context->hdmi_width*3));
            DPI_CHECK_RET(DPI_EnableClk());
            up(&hdmi_update_mutex);
            break;
        }
        case MTK_HDMI_AUDIO_CONFIG:
        {
            if(phdmi_context->is_active == false)
            {
                HDMI_LOG("ignore this ioctl because hdmitx is not active\n");
                break;
            }
HDMI_POLARITY_FALLING
            if (arg) 
            {
                //HDMI_CHECK_RET(hdmi_drv_init());
            } 
            else 
            {
                //HDMI_CHECK_RET(hdmi_drv_deinit());
            }
            
            break;
        }
        default:
        {
            printk("[hdmi][HDMI] arguments error\n");
            break;
        }
    }

    HDMI_LOG("ioctl finished\n");
	return r;    
}

static int hdmi_remove(struct platform_device *pdev)
{
	return 0;
}

static BOOL hdmi_drv_init_context(void)
{
	static const HDMI_UTIL_FUNCS hdmi_utils =
	{
		.udelay             	= hdmi_udelay,
		.mdelay             	= hdmi_mdelay,
		.state_callback			= hdmi_state_callback,
	};

	if (hdmi_drv != NULL) 
		return TRUE;


	hdmi_drv = HDMI_GetDriver();

	if (NULL == hdmi_drv) return FALSE;

	hdmi_drv->set_util_funcs(&hdmi_utils);
	hdmi_drv->get_params(hdmi_params);

	return TRUE;
}

static void __exit hdmi_exit(void)
{
	device_destroy(hdmi_class, hdmi_devno);    
	class_destroy(hdmi_class);
	cdev_del(hdmi_cdev);
	unregister_chrdev_region(hdmi_devno, 1);

}

struct file_operations hdmi_fops = {
	.owner   = THIS_MODULE,
	.unlocked_ioctl   = hdmi_ioctl,
	.open    = hdmi_open,    
	.release = hdmi_release,
};

static int hdmi_probe(struct platform_device *pdev)
{
    printk("[hdmi]%s\n", __func__);
    int ret = 0;
	struct class_device *class_dev = NULL;

	ret = alloc_chrdev_region(&hdmi_devno, 0, 1, HDMI_DEVNAME);
	if(ret)
	{
		printk("[hdmi]alloc_chrdev_region fail\n");
		return -1;
	}

	hdmi_cdev = cdev_alloc();
	hdmi_cdev->owner = THIS_MODULE;
	hdmi_cdev->ops = &hdmi_fops;
	ret = cdev_add(hdmi_cdev, hdmi_devno, 1);
	hdmi_class = class_create(THIS_MODULE, HDMI_DEVNAME);
	class_dev = (struct class_device *)device_create(hdmi_class, NULL, hdmi_devno,	NULL, HDMI_DEVNAME);

	printk("[hdmi][%s] current=0x%08x\n", __func__, current);

    if (!hdmi_drv_init_context()) 
	{
	    printk("[hdmi]%s, hdmi_drv_init_context fail\n", __func__);
		return HDMI_STATUS_NOT_IMPLEMENTED;
	}
    
    init_waitqueue_head(&hdmi_update_wq);

    hdmi_update_task = kthread_create(hdmi_update_kthread, NULL, "hdmi_update_kthread"); 
    wake_up_process(hdmi_update_task);

    return 0;
}

static struct platform_driver hdmi_driver = {
    .probe  = hdmi_probe,
    .remove = hdmi_remove,
    .driver = { .name = HDMI_DEVNAME }
};

static int __init hdmi_init(void)
{
	printk("[hdmi]%s\n", __func__);

	int ret = 0;

    if (platform_driver_register(&hdmi_driver)) 
    {
        printk("[hdmi]failed to register mtkfb driver\n");
        return -1;
    }  
	
	memset((void*)&hdmi_context, 0, sizeof(_t_hdmi_context));
	
	HDMI_DBG_Init();

	hdmi_switch_data.name = "mtk_hdmi";
	hdmi_switch_data.index = 0;
	hdmi_switch_data.state = NO_DEVICE;

	ret = switch_dev_register(&hdmi_switch_data);
	if(ret)
	{
		printk("[hdmi][HDMI]switch_dev_register returned:%d!\n", ret);
		return 1;
	}

	return 0;
}


module_init(hdmi_init);
module_exit(hdmi_exit);
MODULE_AUTHOR("Xuecheng, Zhang <xuecheng.zhang@mediatek.com>");
MODULE_DESCRIPTION("HDMI Driver");
MODULE_LICENSE("GPL");

#endif
